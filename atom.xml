<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wzbus.github.io/</id>
    <title>wzbus</title>
    <updated>2019-09-10T08:29:43.290Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wzbus.github.io/"/>
    <link rel="self" href="https://wzbus.github.io//atom.xml"/>
    <subtitle>Wenzhou</subtitle>
    <logo>https://wzbus.github.io//images/avatar.png</logo>
    <icon>https://wzbus.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, wzbus</rights>
    <entry>
        <title type="html"><![CDATA[百度地图API公交线路绘制]]></title>
        <id>https://wzbus.github.io//post/bmap</id>
        <link href="https://wzbus.github.io//post/bmap">
        </link>
        <updated>2019-09-10T08:01:14.000Z</updated>
        <content type="html"><![CDATA[<p>由于百度地图搜索结果仅能显示单条公交线路，不利于对公交线网的研究，于是我写了这个基于百度地图JavaScript API V3.0的公交线路绘制网站（http://www.84ditu.com）。本文主要介绍绘制公交的基础功能，其中部分代码涉及jQuery。<br>
<img src="https://wzbus.github.io//post-images/1568102615932.jpg" alt="成品图"></p>
<h3 id="申请api密钥">申请API密钥</h3>
<p>首先要有一个百度账号，并且申请成为百度开发者，然后才能申请ak，应用类型选择浏览器端，必须勾选JavaScript API，最后将申请到的ak作为script链接的一部分在html中的head部分引入。</p>
<p><img src="https://wzbus.github.io//post-images/1568102630268.png" alt="ak申请"></p>
<h3 id="生成地图并自动定位">生成地图并自动定位</h3>
<pre><code class="language-js">var map = new BMap.Map(&quot;map&quot;); //&quot;map&quot;为用于展示地图的div的id
var city;
var myCity = new BMap.LocalCity();
myCity.get(getCity);
function getCity (res) {
  if (res) {
    city = res.name;
    map.centerAndZoom(city, 13);
  } else {
    city = &quot;温州市&quot;; //默认城市
  }
}
</code></pre>
<h3 id="判断路线是否已添加">判断路线是否已添加</h3>
<pre><code class="language-js">function addLine (line) {
  if ($.inArray(line, readyAdd) == -1) {
    bus.getBusList(line);
    readyAdd.push(line); //readyAdd为空数组，用于存储已添加的线路名
  } else {
    alert(&quot;该路线已添加&quot;);
  }
}
</code></pre>
<h3 id="检索并生成路线">检索并生成路线</h3>
<pre><code class="language-js">var getPolylineOptions = function getPolylineOptions () { //线路样式配置
  return {
    strokeColor: $(&quot;#strokeColor&quot;).val(),
    strokeWeight: $(&quot;#strokeWeight&quot;).val(),
    strokeOpacity: $(&quot;#strokeOpacity&quot;).val(),
    strokeStyle: $(&quot;#strokeStyle&quot;).val()
  }
};
var bus = new BMap.BusLineSearch(map, {
  onGetBusListComplete: function onGetBusListComplete (result) {
    let busListItem = $(&quot;#busListItem&quot;).val(); //公交上下行
    let fstLine = result.getBusListItem(busListItem);
    bus.getBusLine(fstLine);
  },
  onGetBusLineComplete: function onGetBusLineComplete (busline) {
    polyline = new BMap.Polyline(busline.getPath(), getPolylineOptions());
    let lineName = busline.name.substr(0, busline.name.indexOf(&quot;(&quot;)); //提取线路名
    map.addOverlay(polyline); //添加折线覆盖物
    let stationList = []; //获取站点
    for (let i = 0, len = busline.getNumBusStations(); i &lt; len; i++) {
      let busStation = busline.getBusStation(i);
      let marker = new BMap.Marker(busStation.position, {
        icon: stationIcon
      });
      stationList.push(new BMap.Point(busStation.position.lng, busStation.position.lat));
      if ($(&quot;#strokeStation&quot;).val() == &quot;true&quot;) { //显示站点
        map.addOverlay(marker);
        marker.setTitle(lineName + &quot;:&quot; + busStation.name);
        marker.addEventListener(&quot;click&quot;, function (e) { //单击站点显示信息
          let opts = {
            width: 250,
            height: 80,
            title: e.target.getTitle().substr(e.target.getTitle().indexOf(&quot;:&quot;) + 1)
          };
          let content = busline.name;
          let infoWindow = new BMap.InfoWindow(content, opts);
          let point = new BMap.Point(e.target.getPosition().lng, e.target.getPosition().lat);
          map.openInfoWindow(infoWindow, point);
        });
      }
    }
    if (enableAutoViewport) {
      let view = map.getViewport(eval(stationList));
      map.centerAndZoom(view.center, view.zoom);
    }
    polyline.addEventListener(&quot;dblclick&quot;, function (e) { //双击线路删除路径
      let allOverlay = map.getOverlays();
      for (let i = 0, len = allOverlay.length; i &lt; len; i++) {
        if (allOverlay[i].toString() == &quot;[object Marker]&quot;) {
          if (allOverlay[i].getTitle().substr(0, allOverlay[i].getTitle().indexOf(&quot;:&quot;)) == lineName) {
            allOverlay[i].enableMassClear();
          } else {
            allOverlay[i].disableMassClear();
          }
        } else {
          allOverlay[i].disableMassClear();
        }
      }
      e.target.enableMassClear();
      map.clearOverlays();
      let index = readyAdd.indexOf(lineName);
      readyAdd.splice(index, 1);
    });
    polyline.addEventListener(&quot;mouseover&quot;, function (e) { //移向线路高亮路径
      if (e.target == currentPolyline) {
        return false;
      }
      currentPolyline = e.target;
      lineOpacity = currentPolyline.getStrokeOpacity();
      currentPolyline.setStrokeOpacity(&quot;1&quot;);
    });
    polyline.addEventListener(&quot;mouseout&quot;, function (e) {
      e.target.setStrokeOpacity(lineOpacity);
    })
  }
});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Gulp4.0.2打包HTML项目]]></title>
        <id>https://wzbus.github.io//post/gulp</id>
        <link href="https://wzbus.github.io//post/gulp">
        </link>
        <updated>2019-09-10T07:48:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="项目目录">项目目录</h2>
<p><img src="https://wzbus.github.io//post-images/1568102074198.png" alt="项目目录"><br>
新建一个app目录用于存放源代码，dist目录（会自动生成）用于存放打包后的文件，rev目录（会自动生成）用于存放其它文件名添加Hash值前后的映射信息。<br>
##安装依赖</p>
<pre><code>npm install --save-dev babel-core babel-plugin-transform-remove-strict-mode babel-preset-es2015 del gulp gulp-autoprefixer gulp-babel@7 gulp-cached gulp-clean-css gulp-connect gulp-imagemin gulp-rev gulp-rev-collector gulp-uglify
</code></pre>
<p>理论上第一步只要安装gulp包，就能将项目初始化，为了方便，我就一次性全列出来了，功能可见下面源码中的说明，大家根据需求取舍，建议使用淘宝镜像cnpm来安装。特别说明一下，gulp-babel得安装8.0以下的版本，不然使用ES6语法会报错找不到@babel/core。全部安装完成后效果如下。<br>
<img src="https://wzbus.github.io//post-images/1568102124324.png" alt="package.json"></p>
<h2 id="代码编写">代码编写</h2>
<p>不废话，直接上源码</p>
<pre><code>//.babelrc
{
  &quot;presets&quot;:[&quot;es2015&quot;], //编译为ES5语法
  &quot;plugins&quot;: [&quot;transform-remove-strict-mode&quot;] //关闭严格模式，这里按需求而定
}
</code></pre>
<pre><code>&lt;!--test.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;css/test.css&quot;&gt;
  &lt;title&gt;test&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Test&lt;/h1&gt;
  &lt;img src=&quot;pic/test.png&quot;&gt;
  &lt;script src=&quot;js/test.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code>//test.js
let msg = &quot;test&quot;;
console.log(msg); //ES6语法会被编译为ES5语法，并清除注释
</code></pre>
<pre><code>//gulpfile.babel.js
import gulp from 'gulp'; //引入依赖包，gulp必需
import babel from 'gulp-babel'; //支持ES6语法需要babel相关几个包
import cached from &quot;gulp-cached&quot;;
import autoprefixer from 'gulp-autoprefixer';
import cleanCss from 'gulp-clean-css';
import uglify from 'gulp-uglify';
import rev from 'gulp-rev';
import revCollector from 'gulp-rev-collector';
import imagemin from &quot;gulp-imagemin&quot;;
import connect from &quot;gulp-connect&quot;;
import del from 'del'; //Node原生的清除方法

gulp.task('css', () =&gt; {
  return gulp.src('app/css/**/*.css') //读取css目录下任意多级目录下所有以.css为结尾的文件，最新版gulp中建议使用return语法
    .pipe(cached('css')) //缓存文件，避免每次重复打包
    .pipe(autoprefixer({ //自动加兼容前缀
      overrideBrowserslist: ['&gt; 5%'], //兼容使用率超过5%的浏览器
      cascade: false //前缀美化
    }))
    .pipe(cleanCss({ //压缩CSS
      advanced: false,
      compatibility: 'ie8',
      keepBreaks: false,
      keepSpecialComments: '*'
    }))
    .pipe(rev())
    .pipe(gulp.dest('dist/css')) //保存打包后的CSS文件到dist下的css目录
    .pipe(rev.manifest()) //文件名加Hash值，配合上上行使用
    .pipe(gulp.dest('rev/css')) //保存CSS映射信息
});

gulp.task('js', function () {
  return gulp.src('app/js/**/*.js')
    .pipe(cached('js'))
    .pipe(babel()) 
    .pipe(uglify({ //压缩JS
      mangle: false //是否混淆变量
    }))
    .pipe(rev())
    .pipe(gulp.dest('dist/js'))
    .pipe(rev.manifest())
    .pipe(gulp.dest('rev/js'))
});

gulp.task('pic', function () {
  return gulp.src('app/pic/**/*')
    .pipe(cached('pic'))
    .pipe(imagemin()) //压缩图片，但效果不明显
    .pipe(gulp.dest('dist/pic'));
});

gulp.task('html', function() {
  return gulp.src(['rev/**/*.json', 'app/*.html'])
    .pipe(cached('html'))
    .pipe(revCollector({ //更改HTML源码中链接路径
      replaceReved: true //替换为追加Hash值后的文件名
      dirReplacements: {
         'css': 'css', //将URL中的css替换为css，其实相同则不必写
         'js': 'js'
       }
    }))
    .pipe(gulp.dest('dist'))
});

gulp.task('clear', function () {
  return del(['dist/*']); //每次打包清除dist目录
});

gulp.task(&quot;reload&quot;, function () {
  return gulp.src('app/*.html')
    .pipe(connect.reload()); //页面重新加载
})

gulp.task('watch', function() {
  gulp.watch('app/*.html', gulp.series('html')); //监听html文件变化，执行‘html’任务
  gulp.watch('app/css/**/*.css', gulp.series('css'));
  gulp.watch('app/js/**/*.js', gulp.series('js'));
  gulp.watch('app/pic/**/*', gulp.series('pic'));
  gulp.watch('dist/**/*', gulp.series('reload'));
});
 
gulp.task('connect', function () { 
  connect.server({ //启用本地服务器
    root: 'dist', //根目录
    port: 3000, //端口
    livereload: true //热更新
  });
});

gulp.task('default', gulp.series('clear', gulp.parallel('css', 'js', 'pic'), 'html')); //gulp指令默认执行的任务，series为串行执行，parallel为并行执行。这里先清空dist目录，再编译，后更改html文件

gulp.task('server', gulp.series('default', gulp.parallel('connect', 'watch'))); //开启服务器并实时更新页面
</code></pre>
<h2 id="打包编译">打包编译</h2>
<p>在命令行中输入gulp开始打包，不出意外，你的文件夹下将会多出以下文件。<br>
<img src="https://wzbus.github.io//post-images/1568102145814.png" alt="打包成功"><br>
再输入gulp server指令，可以在localhost:3000查看页面，当有源码改变后，会触发watch中的任务，不必手动刷新便能在页面上看到效果。最后附上这个项目的github地址 <a href="https://github.com/wzbus/gulp">https://github.com/wzbus/gulp</a></p>
]]></content>
    </entry>
</feed>